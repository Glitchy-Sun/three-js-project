<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - express√µes faciais</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				background-color: #666666;
				margin: 0;
				font-family: Arial, sans-serif;
			}
			#info {
				position: absolute;
				top: 10px;
				width: 100%;
				text-align: center;
				color: white;
			}
			#info a {
				color: #00ffff;
			}
			#controls {
				position: absolute;
				top: 80px;
				left: 20px;
				background: rgba(0, 0, 0, 0.9);
				padding: 20px;
				border-radius: 10px;
				color: white;
				max-width: 350px;
				max-height: 80vh;
				overflow-y: auto;
			}
			#controls h3 {
				margin-top: 0;
				color: #00ffff;
			}
			input[type="text"] {
				width: 100%;
				padding: 10px;
				margin: 10px 0;
				border-radius: 5px;
				border: 2px solid #00ffff;
				background: #222;
				color: white;
				font-size: 14px;
			}
			button {
				padding: 8px 15px;
				margin: 5px 5px 5px 0;
				border: none;
				border-radius: 5px;
				background: #00ffff;
				color: #000;
				font-weight: bold;
				cursor: pointer;
				font-size: 12px;
			}
			button:hover {
				background: #00cccc;
			}
			.command-list {
				background: rgba(255, 255, 255, 0.05);
				padding: 10px;
				border-radius: 5px;
				margin: 10px 0;
				font-size: 11px;
			}
			.command-item {
				padding: 5px;
				margin: 3px 0;
				background: rgba(0, 255, 255, 0.1);
				border-radius: 3px;
			}
			#status {
				margin-top: 10px;
				padding: 10px;
				background: rgba(0, 255, 255, 0.2);
				border-radius: 5px;
				font-size: 12px;
			}
			.slider-control {
				margin: 15px 0;
				padding: 10px;
				background: rgba(255, 255, 255, 0.05);
				border-radius: 5px;
			}
			.slider-control label {
				display: block;
				margin-bottom: 5px;
				font-size: 12px;
				color: #00ffff;
			}
			.slider-control input[type="range"] {
				width: 100%;
			}
			.slider-control span {
				font-size: 11px;
				color: #ccc;
			}
		</style>
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> webgpu - Express√µes faciais - Trabalho do T√∫lio<br/>
			model by <a href="https://www.bannaflak.com/face-cap" target="_blank" rel="noopener">Face Cap</a>
		</div>

		<div id="controls">
			<h3>üé≠ Expression Commands</h3>
			
			<label>Modelo Groq:</label>
			<select id="modelName" style="width: 100%; padding: 8px; margin: 5px 0 10px 0; border-radius: 5px; background: #222; color: white; border: 2px solid #00ffff;">
				<option value="llama-3.1-70b-versatile">Llama 3.1 70B (Recomendado)</option>
				<option value="llama-3.1-8b-instant">Llama 3.1 8B (Mais R√°pido)</option>
				<option value="mixtral-8x7b-32768">Mixtral 8x7B</option>
				<option value="llama3-70b-8192">Llama 3 70B</option>
				<option value="llama3-8b-8192">Llama 3 8B</option>
			</select>
			
			<input type="text" id="commandInput" placeholder="Digite uma ou mais express√µes (ex: feliz, triste, surpreso)">
			<button onclick="executeCommand()">‚ñ∂Ô∏è Executar</button>
			<button onclick="resetFace()">üîÑ Reset</button>
			<button onclick="loopExpression()" id="loopBtn">üîÅ Loop Atual</button>
			<button onclick="stopLoop()" id="stopLoopBtn" style="display:none;">‚èπÔ∏è Parar</button>
			
			<div id="status">Digite um comando. A IA criar√° a express√£o automaticamente!</div>
			
			<div style="background: rgba(255, 255, 255, 0.05); padding: 10px; border-radius: 5px; margin-top: 10px; font-size: 10px; color: #aaa;">
				üí° API Key configurada no c√≥digo (linha 29)<br>
				üé¨ As express√µes animam suavemente entre si!<br>
				üîÅ M√∫ltiplas express√µes: separe por v√≠rgula ou "e"<br>
				<strong>Exemplos:</strong><br>
				‚Ä¢ Uma: <code>evil</code><br>
				‚Ä¢ Duas: <code>feliz, triste</code> ou <code>happy and sad</code><br>
				‚Ä¢ Tr√™s+: <code>excited, scared, angry</code>
			</div>


		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
			import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';
			import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
			import { KTX2Loader } from 'three/addons/loaders/KTX2Loader.js';
			import { MeshoptDecoder } from 'three/addons/libs/meshopt_decoder.module.js';
			import { Inspector } from 'three/addons/inspector/Inspector.js';

			const GROQ_API_KEY = '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';
			const DEFAULT_MODEL = 'llama-3.1-70b-versatile';

			// ========== VARI√ÅVEIS GLOBAIS ==========
			let mixer, headMesh, influences, morphTargetDictionary;
			let clock;
			let isAnimating = false;
			let currentAnimation = null;
			let loopInterval = null;
			let lastExpression = null;
			let expressionSequence = [];
			let isPlayingSequence = false;
			
			// ========== DEFINI√á√ÉO DE EXPRESS√ïES APRIMORADAS ==========
			const expressions = {
				// Felicidade
				'feliz': { 
					'mouthSmile_L': 0.9, 
					'mouthSmile_R': 0.9, 
					'eyeSquint_L': 0.4, 
					'eyeSquint_R': 0.4,
					'cheekSquint_L': 0.3,
					'cheekSquint_R': 0.3
				},
				'happy': { 
					'mouthSmile_L': 0.9, 
					'mouthSmile_R': 0.9, 
					'eyeSquint_L': 0.4, 
					'eyeSquint_R': 0.4,
					'cheekSquint_L': 0.3,
					'cheekSquint_R': 0.3
				},
				'smile': { 
					'mouthSmile_L': 0.8, 
					'mouthSmile_R': 0.8,
					'mouthDimple_L': 0.3,
					'mouthDimple_R': 0.3
				},
				
				// Tristeza
				'triste': { 
					'mouthFrown_L': 0.8, 
					'mouthFrown_R': 0.8, 
					'browInnerUp': 0.7,
					'eyeSquint_L': 0.3,
					'eyeSquint_R': 0.3,
					'mouthLowerDown_L': 0.4,
					'mouthLowerDown_R': 0.4
				},
				'sad': { 
					'mouthFrown_L': 0.8, 
					'mouthFrown_R': 0.8, 
					'browInnerUp': 0.7,
					'eyeSquint_L': 0.3,
					'eyeSquint_R': 0.3,
					'mouthLowerDown_L': 0.4,
					'mouthLowerDown_R': 0.4
				},
				
				// Surpresa
				'surpreso': { 
					'jawOpen': 0.7, 
					'mouthOpen': 0.6, 
					'browInnerUp': 0.9,
					'browOuterUp_L': 0.8,
					'browOuterUp_R': 0.8,
					'eyeWide_L': 0.9, 
					'eyeWide_R': 0.9
				},
				'surprised': { 
					'jawOpen': 0.7, 
					'mouthOpen': 0.6, 
					'browInnerUp': 0.9,
					'browOuterUp_L': 0.8,
					'browOuterUp_R': 0.8,
					'eyeWide_L': 0.9, 
					'eyeWide_R': 0.9
				},
				
				// Raiva
				'bravo': { 
					'mouthFrown_L': 0.7, 
					'mouthFrown_R': 0.7, 
					'browDown_L': 0.9, 
					'browDown_R': 0.9, 
					'noseSneer_L': 0.6, 
					'noseSneer_R': 0.6,
					'jawForward': 0.4,
					'mouthPress_L': 0.5,
					'mouthPress_R': 0.5
				},
				'angry': { 
					'mouthFrown_L': 0.7, 
					'mouthFrown_R': 0.7, 
					'browDown_L': 0.9, 
					'browDown_R': 0.9, 
					'noseSneer_L': 0.6, 
					'noseSneer_R': 0.6,
					'jawForward': 0.4,
					'mouthPress_L': 0.5,
					'mouthPress_R': 0.5
				},
				
				// Malvado/Evil
				'evil': {
					'mouthSmile_L': 0.6,
					'mouthSmile_R': 0.3,  // Sorriso assim√©trico
					'browDown_L': 0.5,
					'browDown_R': 0.7,    // Sobrancelhas assim√©tricas
					'eyeSquint_L': 0.4,
					'eyeSquint_R': 0.6,
					'noseSneer_R': 0.3,
					'mouthSmile_L': 0.5,
					'mouthFrown_R': 0.2
				},
				'malvado': {
					'mouthSmile_L': 0.6,
					'mouthSmile_R': 0.3,
					'browDown_L': 0.5,
					'browDown_R': 0.7,
					'eyeSquint_L': 0.4,
					'eyeSquint_R': 0.6,
					'noseSneer_R': 0.3
				},
				
				// Outras express√µes
				'piscar': { 
					'eyeBlink_L': 1.0, 
					'eyeBlink_R': 1.0 
				},
				'blink': { 
					'eyeBlink_L': 1.0, 
					'eyeBlink_R': 1.0 
				},
				
				'beijar': { 
					'mouthPucker': 0.9, 
					'mouthFunnel': 0.7,
					'eyeBlink_L': 0.5,
					'eyeBlink_R': 0.5
				},
				'kiss': { 
					'mouthPucker': 0.9, 
					'mouthFunnel': 0.7,
					'eyeBlink_L': 0.5,
					'eyeBlink_R': 0.5
				},
				
				'falar': { 
					'jawOpen': 0.5, 
					'mouthOpen': 0.4,
					'tongueOut': 0.1
				},
				'talk': { 
					'jawOpen': 0.5, 
					'mouthOpen': 0.4,
					'tongueOut': 0.1
				},
				
				'pensativo': { 
					'browInnerUp': 0.4,
					'browDown_L': 0.2, 
					'browDown_R': 0.2, 
					'eyeSquint_L': 0.2, 
					'eyeSquint_R': 0.2, 
					'mouthPress_L': 0.3, 
					'mouthPress_R': 0.3,
					'mouthRollLower': 0.2
				},
				'thinking': { 
					'browInnerUp': 0.4,
					'browDown_L': 0.2, 
					'browDown_R': 0.2, 
					'eyeSquint_L': 0.2, 
					'eyeSquint_R': 0.2, 
					'mouthPress_L': 0.3, 
					'mouthPress_R': 0.3,
					'mouthRollLower': 0.2
				}
			};

			init();

			async function init() {

				clock = new THREE.Clock();

				const camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 20 );
				camera.position.set( - 1.8, 0.8, 3 );

				const scene = new THREE.Scene();

				const renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				renderer.toneMapping = THREE.ACESFilmicToneMapping;
				renderer.inspector = new Inspector();
				document.body.appendChild( renderer.domElement );

				await renderer.init();

				const environment = new RoomEnvironment();
				const pmremGenerator = new THREE.PMREMGenerator( renderer );

				scene.background = new THREE.Color( 0x666666 );
				scene.environment = pmremGenerator.fromScene( environment ).texture;

				const ktx2Loader = await new KTX2Loader()
					.setTranscoderPath( 'jsm/libs/basis/' )
					.detectSupport( renderer );

				new GLTFLoader()
					.setKTX2Loader( ktx2Loader )
					.setMeshoptDecoder( MeshoptDecoder )
					.load( 'models/gltf/facecap.glb', ( gltf ) => {

						const mesh = gltf.scene.children[ 0 ];
						scene.add( mesh );

						// ========== MIXER REMOVIDO - SEM ANIMA√á√ÉO AUTOM√ÅTICA ==========
						// mixer = new THREE.AnimationMixer( mesh );
						// mixer.clipAction( gltf.animations[ 0 ] ).play();

						// ========== CAPTURA DOS PAR√ÇMETROS ==========
						headMesh = mesh.getObjectByName( 'mesh_2' );
						influences = headMesh.morphTargetInfluences;
						morphTargetDictionary = headMesh.morphTargetDictionary;

						console.log('=== MORPH TARGETS DISPON√çVEIS ===');
						console.log(morphTargetDictionary);

						// GUI do Inspector
						const gui = renderer.inspector.createParameters( 'Morph Targets' );

						for ( const [ key, value ] of Object.entries( morphTargetDictionary ) ) {
							gui.add( influences, value, 0, 1, 0.01 )
								.name( key.replace( 'blendShape1.', '' ) )
								.listen();
						}

						// Criar controles manuais removidos - sem sliders

						updateStatus('‚úÖ Modelo carregado! ' + Object.keys(morphTargetDictionary).length + ' par√¢metros dispon√≠veis.');

					} );

				scene.background = new THREE.Color( 0x666666 );

				const controls = new OrbitControls( camera, renderer.domElement );
				controls.enableDamping = true;
				controls.minDistance = 2.5;
				controls.maxDistance = 5;
				controls.minAzimuthAngle = - Math.PI / 2;
				controls.maxAzimuthAngle = Math.PI / 2;
				controls.maxPolarAngle = Math.PI / 1.8;
				controls.target.set( 0, 0.15, - 0.2 );

				function animate() {

					const delta = clock.getDelta();

					// ========== MIXER REMOVIDO ==========
					// if ( mixer ) {
					// 	mixer.update( delta );
					// }

					renderer.render( scene, camera );
					controls.update();

				}

				window.addEventListener( 'resize', () => {

					camera.aspect = window.innerWidth / window.innerHeight;
					camera.updateProjectionMatrix();

					renderer.setSize( window.innerWidth, window.innerHeight );

				} );

			}

			// ========== FUN√á√ïES DE CONTROLE ==========

			function updateStatus(message) {
				document.getElementById('status').textContent = message;
			}

			window.executeCommand = async function() {
				const command = document.getElementById('commandInput').value.trim().toLowerCase();
				
				if (!command) {
					updateStatus('‚ö†Ô∏è Digite um comando!');
					return;
				}

				if (!influences) {
					updateStatus('‚ö†Ô∏è Aguarde o modelo carregar!');
					return;
				}

				// Detectar se h√° m√∫ltiplas express√µes (separadas por v√≠rgula, "e", "and", "ent√£o", "depois")
				const separators = /,|\se\s|\sand\s|\sent√£o\s|\sdepois\s|\sen\s/i;
				const commands = command.split(separators).map(c => c.trim()).filter(c => c);

				if (commands.length > 1) {
					// M√∫ltiplas express√µes - criar sequ√™ncia
					updateStatus(`üé¨ Detectadas ${commands.length} express√µes. Processando sequ√™ncia...`);
					await processExpressionSequence(commands);
				} else {
					// Express√£o √∫nica
					if (expressions[command]) {
						applyExpression(command);
						lastExpression = expressions[command];
						updateStatus(`‚úÖ Express√£o "${command}" aplicada com anima√ß√£o!`);
					} else {
						updateStatus(`ü§ñ Usando IA para interpretar "${command}"...`);
						await useAIToInterpret(command);
					}
				}
			}

			async function processExpressionSequence(commands) {
				expressionSequence = [];

				// Processar cada comando
				for (let i = 0; i < commands.length; i++) {
					const cmd = commands[i];
					updateStatus(`ü§ñ Processando ${i + 1}/${commands.length}: "${cmd}"...`);

					if (expressions[cmd]) {
						// Express√£o pr√©-definida
						expressionSequence.push({
							name: cmd,
							params: expressions[cmd]
						});
					} else {
						// Usar IA
						const params = await getExpressionFromAI(cmd);
						if (params) {
							expressionSequence.push({
								name: cmd,
								params: params
							});
							expressions[cmd] = params;
						}
					}
				}

				if (expressionSequence.length > 0) {
					updateStatus(`‚úÖ Sequ√™ncia de ${expressionSequence.length} express√µes pronta! Iniciando...`);
					playExpressionSequence();
				} else {
					updateStatus(`‚ùå N√£o foi poss√≠vel criar a sequ√™ncia`);
				}
			}

			async function getExpressionFromAI(command) {
				const apiKey = GROQ_API_KEY;
				const model = document.getElementById('modelName').value;

				if (!apiKey || apiKey === 'SUA_CHAVE_AQUI') {
					return null;
				}

				try {
					const availableParams = Object.keys(morphTargetDictionary)
						.map(k => k.replace('blendShape1.', ''))
						.join(', ');

					const systemPrompt = `You are an expert in facial animation and ARKit blendshapes. You create realistic facial expressions by combining multiple facial parameters.

CRITICAL RULES:
1. ALWAYS use asymmetry for complex emotions (different values for _L and _R)
2. Combine multiple muscle groups (eyes, brows, mouth, nose, jaw)
3. Use subtle values (0.3-0.7) for most parameters, reserve 0.8-1.0 for extreme expressions
4. Return ONLY valid JSON, no markdown, no explanations

Example of good asymmetric expression (evil/smirk):
{"mouthSmile_L": 0.6, "mouthSmile_R": 0.2, "browDown_L": 0.4, "browDown_R": 0.7, "eyeSquint_L": 0.3, "eyeSquint_R": 0.5}`;

					const userPrompt = `Create facial expression for: "${command}"

Available parameters: ${availableParams}

Return ONLY JSON format (no markdown):
{"parameter1": value, "parameter2": value}

Expression: "${command}"
JSON:`;

					const response = await fetch('https://api.groq.com/openai/v1/chat/completions', {
						method: 'POST',
						headers: {
							'Authorization': `Bearer ${apiKey}`,
							'Content-Type': 'application/json'
						},
						body: JSON.stringify({
							model: model,
							messages: [
								{ role: 'system', content: systemPrompt },
								{ role: 'user', content: userPrompt }
							],
							temperature: 0.8,
							max_tokens: 1500,
							top_p: 0.9
						})
					});

					if (!response.ok) {
						return null;
					}

					const data = await response.json();
					const aiResponse = data.choices[0].message.content.trim();

					let cleanResponse = aiResponse
						.replace(/```json\s*/g, '')
						.replace(/```\s*/g, '')
						.trim();

					const jsonMatch = cleanResponse.match(/\{[\s\S]*\}/);
					if (jsonMatch) {
						return JSON.parse(jsonMatch[0]);
					}

					return null;

				} catch (error) {
					console.error('Erro ao obter express√£o da IA:', error);
					return null;
				}
			}

			function playExpressionSequence() {
				if (isPlayingSequence) {
					stopSequence();
				}

				isPlayingSequence = true;
				let currentIndex = 0;

				function playNext() {
					if (!isPlayingSequence || currentIndex >= expressionSequence.length) {
						// Reiniciar sequ√™ncia
						currentIndex = 0;
						if (!isPlayingSequence) return;
					}

					const expr = expressionSequence[currentIndex];
					updateStatus(`üé¨ Reproduzindo: "${expr.name}" (${currentIndex + 1}/${expressionSequence.length})`);

					animateToExpression(expr.params, 1.5);
					lastExpression = expr.params;

					currentIndex++;

					// Pr√≥xima express√£o ap√≥s 3 segundos
					setTimeout(playNext, 3000);
				}

				// Iniciar sequ√™ncia
				playNext();

				// Atualizar bot√µes
				document.getElementById('loopBtn').style.display = 'none';
				document.getElementById('stopLoopBtn').style.display = 'inline-block';
			}

			function stopSequence() {
				isPlayingSequence = false;
				expressionSequence = [];
				
				document.getElementById('loopBtn').style.display = 'inline-block';
				document.getElementById('stopLoopBtn').style.display = 'none';
				
				updateStatus('‚èπÔ∏è Sequ√™ncia parada');
			}

			window.loopExpression = function() {
				if (!lastExpression || !influences) {
					updateStatus('‚ö†Ô∏è Execute uma express√£o primeiro!');
					return;
				}

				// Parar loop anterior se existir
				stopLoop();

				document.getElementById('loopBtn').style.display = 'none';
				document.getElementById('stopLoopBtn').style.display = 'inline-block';

				updateStatus('üîÅ Loop ativo - alternando entre neutro e express√£o');

				let isNeutral = false;

				function toggleExpression() {
					if (isNeutral) {
						animateToExpression(lastExpression, 1.5);
					} else {
						const neutral = {};
						for (let i = 0; i < influences.length; i++) {
							neutral[i] = 0;
						}
						animateToExpression(neutral, 1.5);
					}
					isNeutral = !isNeutral;
				}

				// Iniciar com a express√£o
				animateToExpression(lastExpression, 1.5);
				isNeutral = true;

				// Loop a cada 3 segundos
				loopInterval = setInterval(toggleExpression, 3000);
			}

			window.stopLoop = function() {
				if (loopInterval) {
					clearInterval(loopInterval);
					loopInterval = null;
				}

				// Parar sequ√™ncia tamb√©m
				if (isPlayingSequence) {
					stopSequence();
				}

				document.getElementById('loopBtn').style.display = 'inline-block';
				document.getElementById('stopLoopBtn').style.display = 'none';

				updateStatus('‚èπÔ∏è Loop parado');
			}

			async function useAIToInterpret(command) {
				const apiKey = GROQ_API_KEY; // Usa a chave fixa do c√≥digo
				const model = document.getElementById('modelName').value;
				
				if (!apiKey || apiKey === 'SUA_CHAVE_AQUI') {
					updateStatus('‚ö†Ô∏è Configure a GROQ_API_KEY no c√≥digo! Linha 29');
					return;
				}

				if (!apiKey.startsWith('gsk_')) {
					updateStatus('‚ö†Ô∏è API Key inv√°lida! Groq keys come√ßam com "gsk_"');
					return;
				}

				updateStatus(`ü§ñ Groq (${model}) interpretando "${command}"...`);

				try {
					// Criar lista de par√¢metros dispon√≠veis
					const availableParams = Object.keys(morphTargetDictionary)
						.map(k => k.replace('blendShape1.', ''))
						.join(', ');

					const systemPrompt = `You are an expert in facial animation and ARKit blendshapes. You create realistic facial expressions by combining multiple facial parameters.

CRITICAL RULES:
1. ALWAYS use asymmetry for complex emotions (different values for _L and _R)
2. Combine multiple muscle groups (eyes, brows, mouth, nose, jaw)
3. Use subtle values (0.3-0.7) for most parameters, reserve 0.8-1.0 for extreme expressions
4. Return ONLY valid JSON, no markdown, no explanations

Example of good asymmetric expression (evil/smirk):
{"mouthSmile_L": 0.6, "mouthSmile_R": 0.2, "browDown_L": 0.4, "browDown_R": 0.7, "eyeSquint_L": 0.3, "eyeSquint_R": 0.5}`;
					
					const userPrompt = `Create facial expression for: "${command}"

Available parameters (use exact names):
${availableParams}

KEY PARAMETER GROUPS:

MOUTH:
- mouthSmile_L/R: corners up (smile)
- mouthFrown_L/R: corners down (frown)
- mouthPucker: lips forward (kiss)
- mouthFunnel: lips funnel in
- mouthPress_L/R: lips pressed together
- mouthRollLower/Upper: lips rolled in
- mouthShrugLower/Upper: lip shrug
- mouthLowerDown_L/R: lower lip down
- mouthUpperUp_L/R: upper lip up
- jawOpen: jaw opening
- jawForward: jaw forward (aggressive)
- jawLeft/Right: jaw sideways

EYES:
- eyeBlink_L/R: close eyes (0=open, 1=closed)
- eyeWide_L/R: wide eyes (surprise, fear)
- eyeSquint_L/R: squint (smile, suspicion)
- eyeLookUp/Down/Left/Right: gaze direction

BROWS:
- browDown_L/R: lower brow (anger, focus)
- browInnerUp: inner brow up (sadness, pleading)
- browOuterUp_L/R: outer brow up (surprise)

NOSE/CHEEKS:
- noseSneer_L/R: nose wrinkle (disgust, anger)
- cheekPuff: puff cheeks
- cheekSquint_L/R: cheek raise (smile)

EMOTION GUIDELINES:
- Evil/Smirk: Asymmetric smile, one brow lower, slight squint
- Angry: Symmetric frown, both brows down, nose sneer, jaw forward
- Sad: Frown, inner brows up, slight squint
- Happy: Symmetric smile, cheek squint, slight eye squint
- Scared: Wide eyes, brows up, mouth open
- Disgusted: Nose sneer, upper lip up, brows down

Return ONLY JSON format (no markdown):
{"parameter1": value, "parameter2": value}

Expression: "${command}"
JSON:`;

					const response = await fetch('https://api.groq.com/openai/v1/chat/completions', {
						method: 'POST',
						headers: {
							'Authorization': `Bearer ${apiKey}`,
							'Content-Type': 'application/json'
						},
						body: JSON.stringify({
							model: model,
							messages: [
								{ role: 'system', content: systemPrompt },
								{ role: 'user', content: userPrompt }
							],
							temperature: 0.8,
							max_tokens: 1500,
							top_p: 0.9
						})
					});

					if (!response.ok) {
						const errorData = await response.json();
						console.error('Erro da API:', errorData);
						throw new Error(`Groq API Error ${response.status}: ${errorData.error?.message || 'Verifique sua API Key'}`);
					}

					const data = await response.json();
					const aiResponse = data.choices[0].message.content.trim();
					
					console.log('Resposta bruta da IA:', aiResponse);
					
					// Fazer parse do JSON retornado
					let expressionParams;
					try {
						// Remover markdown se existir (```json ... ```)
						let cleanResponse = aiResponse
							.replace(/```json\s*/g, '')
							.replace(/```\s*/g, '')
							.trim();
						
						// Tentar encontrar JSON no texto
						const jsonMatch = cleanResponse.match(/\{[\s\S]*\}/);
						if (jsonMatch) {
							expressionParams = JSON.parse(jsonMatch[0]);
						} else {
							expressionParams = JSON.parse(cleanResponse);
						}
					} catch (parseError) {
						console.error('Erro ao fazer parse. Resposta da IA:', aiResponse);
						updateStatus('‚ùå IA retornou formato inv√°lido. Tentando novamente com comando simplificado...');
						
						// Tentar uma segunda vez com prompt mais simples
						return await retryWithSimplePrompt(command, apiKey, model);
					}

					// Validar que temos pelo menos um par√¢metro
					if (!expressionParams || Object.keys(expressionParams).length === 0) {
						throw new Error('IA n√£o retornou par√¢metros faciais');
					}

					console.log('Par√¢metros extra√≠dos:', expressionParams);

					// Aplicar a express√£o gerada pela IA
					applyCustomExpression(expressionParams);
					
					// Salvar na lista de express√µes para uso futuro
					expressions[command] = expressionParams;
					lastExpression = expressionParams;
					
					updateStatus(`‚úÖ "${command}" criado pela Groq e aplicado com anima√ß√£o! (${Object.keys(expressionParams).length} par√¢metros)`);

				} catch (error) {
					console.error('Erro completo:', error);
					updateStatus(`‚ùå Erro: ${error.message}`);
				}
			}

			async function retryWithSimplePrompt(command, apiKey, model) {
				try {
					const simplePrompt = `You are a facial expression animator. Create JSON for "${command}" expression.

Use these ARKit blendshapes with values 0-1:

MOUTH: mouthSmile_L, mouthSmile_R, mouthFrown_L, mouthFrown_R, mouthPucker, mouthPress_L, mouthPress_R, jawOpen, jawForward
EYES: eyeBlink_L, eyeBlink_R, eyeWide_L, eyeWide_R, eyeSquint_L, eyeSquint_R
BROWS: browDown_L, browDown_R, browInnerUp, browOuterUp_L, browOuterUp_R
NOSE: noseSneer_L, noseSneer_R
CHEEKS: cheekSquint_L, cheekSquint_R

IMPORTANT: Use asymmetry (different L/R values) for complex emotions!

Examples:
Evil: {"mouthSmile_L": 0.6, "mouthSmile_R": 0.2, "browDown_R": 0.7, "eyeSquint_R": 0.5}
Angry: {"mouthFrown_L": 0.7, "mouthFrown_R": 0.7, "browDown_L": 0.9, "browDown_R": 0.9, "noseSneer_L": 0.6, "noseSneer_R": 0.6}
Happy: {"mouthSmile_L": 0.9, "mouthSmile_R": 0.9, "eyeSquint_L": 0.4, "eyeSquint_R": 0.4, "cheekSquint_L": 0.3, "cheekSquint_R": 0.3}

Return ONLY JSON for "${command}":`;

					const response = await fetch('https://api.groq.com/openai/v1/chat/completions', {
						method: 'POST',
						headers: {
							'Authorization': `Bearer ${apiKey}`,
							'Content-Type': 'application/json'
						},
						body: JSON.stringify({
							model: model,
							messages: [{ role: 'user', content: simplePrompt }],
							temperature: 0.8,
							max_tokens: 800
						})
					});

					const data = await response.json();
					const aiResponse = data.choices[0].message.content.trim();
					console.log('Resposta do retry:', aiResponse);
					
					const jsonMatch = aiResponse.match(/\{[\s\S]*\}/);
					if (!jsonMatch) {
						throw new Error('N√£o foi poss√≠vel extrair JSON da resposta');
					}
					
					const expressionParams = JSON.parse(jsonMatch[0]);

					applyCustomExpression(expressionParams);
					expressions[command] = expressionParams;
					lastExpression = expressionParams;
					updateStatus(`‚úÖ "${command}" criado (modo simplificado) e aplicado com anima√ß√£o!`);

				} catch (retryError) {
					updateStatus(`‚ùå N√£o foi poss√≠vel criar a express√£o. Tente outro comando.`);
					console.error('Erro no retry:', retryError);
				}
			}

			function applyCustomExpression(expressionParams) {
				// Animar suavemente para a express√£o customizada
				animateToExpression(expressionParams, 1.2);
			}

			function applyExpression(expressionName) {
				const expression = expressions[expressionName];
				
				// Animar suavemente para a express√£o
				animateToExpression(expression, 1.0);
			}

			function animateToExpression(targetExpression, duration = 1.0) {
				if (!influences) return;

				// Cancelar anima√ß√£o anterior se existir
				if (currentAnimation) {
					cancelAnimationFrame(currentAnimation);
				}

				// Salvar valores iniciais
				const startValues = {};
				for (let i = 0; i < influences.length; i++) {
					startValues[i] = influences[i];
				}

				// Preparar valores alvo
				const targetValues = {};
				
				// Reset todos primeiro
				for (let i = 0; i < influences.length; i++) {
					targetValues[i] = 0;
				}
				
				// Aplicar valores da express√£o
				for (const [paramName, value] of Object.entries(targetExpression)) {
					const index = getParamIndex(paramName);
					if (index !== -1) {
						targetValues[index] = value;
					}
				}

				// Animar
				const startTime = Date.now();
				
				function animate() {
					const elapsed = (Date.now() - startTime) / 1000;
					const progress = Math.min(elapsed / duration, 1);
					
					// Easing suave (ease-in-out)
					const eased = progress < 0.5 
						? 2 * progress * progress 
						: 1 - Math.pow(-2 * progress + 2, 2) / 2;
					
					// Interpolar todos os valores
					for (let i = 0; i < influences.length; i++) {
						const start = startValues[i] || 0;
						const target = targetValues[i] || 0;
						influences[i] = start + (target - start) * eased;
					}
					
					if (progress < 1) {
						currentAnimation = requestAnimationFrame(animate);
					} else {
						currentAnimation = null;
					}
				}
				
				animate();
			}

			function getParamIndex(paramName) {
				for (const [key, index] of Object.entries(morphTargetDictionary)) {
					const cleanKey = key.replace('blendShape1.', '').toLowerCase();
					if (cleanKey === paramName.toLowerCase()) {
						return index;
					}
				}
				return -1;
			}

			window.resetFace = function() {
				if (!influences) return;
				
				// Cancelar anima√ß√£o atual
				if (currentAnimation) {
					cancelAnimationFrame(currentAnimation);
					currentAnimation = null;
				}
				
				// Animar suavemente para posi√ß√£o neutra
				const neutralExpression = {};
				for (let i = 0; i < influences.length; i++) {
					neutralExpression[i] = 0;
				}
				
				const startTime = Date.now();
				const duration = 0.8;
				
				const startValues = {};
				for (let i = 0; i < influences.length; i++) {
					startValues[i] = influences[i];
				}
				
				function animate() {
					const elapsed = (Date.now() - startTime) / 1000;
					const progress = Math.min(elapsed / duration, 1);
					
					const eased = progress < 0.5 
						? 2 * progress * progress 
						: 1 - Math.pow(-2 * progress + 2, 2) / 2;
					
					for (let i = 0; i < influences.length; i++) {
						influences[i] = startValues[i] * (1 - eased);
					}
					
					if (progress < 1) {
						currentAnimation = requestAnimationFrame(animate);
					} else {
						currentAnimation = null;
					}
				}
				
				animate();
				updateStatus('üîÑ Face resetada');
			}
			document.addEventListener('DOMContentLoaded', () => {
				const input = document.getElementById('commandInput');
				if (input) {
					input.addEventListener('keypress', (e) => {
						if (e.key === 'Enter') {
							executeCommand();
						}
					});
				}
			});

		</script>
	</body>
</html>